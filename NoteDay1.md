# Node.js 第1天

## 上午總結

- Node.js 是什麼
  + JavaScript 運行時
  + 既不是語言，也不是框架，它是一個平臺
- Node.js 中的 JavaScript
  + 沒有 BOM、DOM
  + EcmaScript 基本的 JavaScript 語言部分
  + 在 Node 中為 JavaScript 提供了一些服務器級別的 API
    * 文件操作的能力
    * http 服務的能力

## 總結

- Node 中的 JavaScript
  + EcmaScript
    * 變量
    * 方法
    * 數據類型
    * 內置對象
    * Array
    * Object
    * Date
    * Math
  + 模塊系統
    * 在 Node 中沒有全局作用域的概念
    * 在 Node 中，只能通過 require 方法來加載執行多個 JavaScript 腳本文件
    * require 加載只能是執行其中的代碼，文件與文件之間由於是模塊作用域，所以不會有汙染的問題
      - 模塊完全是封閉的
      - 外部無法訪問內部
      - 內部也無法訪問外部
    * 模塊作用域固然帶來了一些好處，可以加載執行多個文件，可以完全避免變量命名衝突汙染的問題
    * 但是某些情況下，模塊與模塊是需要進行通信的
    * 在每個模塊中，都提供了一個對象：`exports`
    * 該對象默認是一個空對象
    * 你要做的就是把需要被外部訪問使用的成員手動的掛載到 `exports` 接口對象中
    * 然後誰來 `require` 這個模塊，誰就可以得到模塊內部的 `exports` 接口對象
    * 還有其它的一些規則，具體後面講，以及如何在項目中去使用這種編程方式，會通過後面的案例來處理
  + 核心模塊
    * 核心模塊是由 Node 提供的一個個的具名的模塊，它們都有自己特殊的名稱標識，例如
      - fs 文件操作模塊
      - http 網絡服務構建模塊
      - os 操作系統信息模塊
      - path 路徑處理模塊
      - 。。。。
    * 所有核心模塊在使用的時候都必須手動的先使用 `require` 方法來加載，然後才可以使用，例如：
      - `var fs = require('fs')`
- http
  + require
  + 端口號
    * ip 地址定位計算機
    * 端口號定位具體的應用程序
  + Content-Type
    * 服務器最好把每次響應的數據是什麼內容類型都告訴客戶端，而且要正確的告訴
    * 不同的資源對應的 Content-Type 是不一樣，具體參照：http://tool.oschina.net/commons
    * 對於文本類型的數據，最好都加上編碼，目的是為了防止中文解析亂碼問題
  + 通過網絡發送文件
    * 發送的並不是文件，本質上來講發送是文件的內容
    * 當瀏覽器收到服務器響應內容之後，就會根據你的 Content-Type 進行對應的解析處理

- 模塊系統
- Node 中的其它的核心模塊
- 做一個小管理系統：
  + CRUD
- Express Web 開發框架
  + `npm install express`
